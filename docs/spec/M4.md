# CURSED — Milestone M4
## Global Phase Advancement Engine

---

## 0. CRITICAL IMPLEMENTATION RULE (APPLIES TO THIS AND ALL FUTURE MILESTONES)

When implementing this milestone (and every milestone thereafter):

- **All non-trivial code MUST include explicit, explanatory comments**
- Comments must:
  - explain **what the code does**
  - explain **why it exists**
  - explain **how it fits into the larger system**
- Comments must be written so that:
  - a third party with no prior context
  - or a future maintainer months/years later  
    can understand the intent and structure without external documentation

This is not optional.  
Lack of clear comments is considered incomplete implementation.

### COMMENTING RULE (CLARIFICATION — NON-NEGOTIABLE)

- Comments are written **at the moment code is created**, not afterward.
- There is **no separate “commenting phase”**.
- No class, method, or non-trivial logic may exist without comments explaining:
  - its responsibility
  - its boundaries
  - and why it exists at that location in the system.
- If a piece of code cannot be clearly commented while being written, implementation **must pause** and the design must be reconsidered.
- “We will add comments later” is considered **invalid and incomplete implementation**.

---

## 1. Purpose of M4

Milestone M4 introduces phase advancement as a first-class game mechanic.

It defines when and how the global run phase advances, based strictly on objective completion, and how phase transitions affect objective and task availability.

M4 does not introduce new objectives, tasks, or player action wiring. It builds directly on the objective, task, and progress engine established in M2 and M3.

Phase advancement is deterministic, global, and server-authoritative. When a phase advances, all teams are affected simultaneously, while preserving the ability for teams to complete objectives and tasks from earlier phases.

This milestone establishes phase progression as a stable backbone for later systems such as scoring, curses, rewards, pacing, and win conditions.

---

## 2. Scope

### Included in M4
- Global phase advancement logic
- Explicit trigger rules for phase advancement
- Server-authoritative phase state transitions
- Phase transition mechanics (unlocking new objectives/tasks)
- Persistence and restart safety for phase state
- Debug visibility and admin control for phase transitions

### Explicitly Excluded from M4
- Scoring or points
- Rewards, curses, penalties, or effects
- Win or loss conditions
- Time-based phase advancement
- Per-team phase divergence
- New objective or task types
- Player-facing UI beyond minimal debug feedback

Phase advancement in M4 is purely **structural and mechanical**, not experiential.

---

## 3. Phase Advancement Trigger Rules

### Global phase model
- There is exactly **one global phase** for the entire server.
- Phase advancement affects all teams simultaneously.

### Trigger condition
- The global phase advances **only** when the **PRIMARY objective of the current phase** is completed.
- Only PRIMARY objectives can trigger phase advancement.
- SECONDARY objectives and TASKS never trigger phase advancement.

### Trigger source
- Completion of the PRIMARY objective by **any team** triggers the phase advance.
- Phase advancement is not team-specific.

### Single-trigger guarantee
- Each phase may advance **exactly once**.
- Once a phase advances, it cannot advance again for that phase, even if other teams later complete the PRIMARY objective from the previous phase.

### Late completion behavior
- Teams that did not complete the PRIMARY objective before the phase advanced may still complete it later.
- Late completion does **not** trigger further phase advancement.
- Late completion still marks the objective as completed for that team.

### Upper bound
- The phase cannot advance beyond the maximum defined phase.
- Completing the PRIMARY objective of the final phase does not advance the phase further.

### Atomicity
- Phase advancement is an atomic state transition:
  - phase value increments
  - newly unlocked objectives/tasks become available
  - state is persisted immediately

---

## 4. Phase Transition Mechanics

### Authoritative execution
- Phase advancement is executed **once**, server-side, under a lock.
- Concurrent completion events must not trigger multiple transitions.

### Transition ordering
When a phase advance is triggered, the engine performs the following steps in order:

1) Lock phase advancement
2) Increment `currentPhase` by 1
3) Recompute objective/task availability based on new phase
4) Persist updated run state
5) Release phase lock

No gameplay events are processed during the transition.

### Availability semantics
- Objectives and tasks with `unlockPhase <= currentPhase` become available.
- Availability is derived from phase value only.
- Objectives/tasks from earlier phases remain available unless already completed.

### State immutability
- Objective and task definitions are never modified during phase transition.
- Team progress and completion state remain unchanged.
- No objectives or tasks are regenerated or reassigned.

### Failure handling
- If persistence fails during phase transition:
  - the phase must not advance
  - the system must roll back to the previous stable state
- Partial phase transitions must never be observable.

### Restart safety
- After restart, the system must restore:
  - the correct `currentPhase`
  - correct objective/task availability
- Phase advancement must not re-trigger on restart.

### Observability
- Debug inspection must show:
  - currentPhase
  - which objectives/tasks became newly unlocked
- Optional minimal broadcast message may announce phase change (non-UI).

---

## 5. Debug & Administrative Phase Controls

### Phase inspection
- Debug/admin commands must allow inspection of:
  - current global phase
  - maximum defined phase
  - whether phase advancement is currently possible
- Inspection must be read-only and safe at any time.

### Manual phase advancement (debug-only)
- A debug/admin-only command may allow manual phase advancement.
- Manual advancement:
  - must respect the maximum phase bound
  - must use the same transition path as automatic advancement
  - must persist state identically

Manual advancement exists solely for testing and recovery.

### Manual phase rollback (optional)
- If supported:
  - must be debug-only
  - must not delete objective/task completion state
  - must only modify `currentPhase`

Rollback is unsafe for real gameplay and intended only for development/testing.

### Safety guarantees
- All debug/admin phase controls must:
  - be gated behind debug configuration
  - never bypass persistence
  - never create impossible phase states

### Logging & visibility
- All manual phase changes must be logged clearly.
- Optional minimal chat feedback for testing visibility.

---

## 6. Integrity Rules

- Phase advancement must be deterministic and server-authoritative
- No per-team phase divergence is allowed
- No side effects beyond availability changes occur during phase transition
- Phase state is always recoverable after restart
- Phase logic must not depend on player presence or online state

---

## 7. Explicit Implementation Steps (Authoritative)

Implementation must proceed in this order:

1) Introduce a phase advancement lock mechanism
2) Detect PRIMARY objective completion events
3) Validate that the completed PRIMARY belongs to the current phase
4) Trigger phase advancement exactly once per phase
5) Increment `currentPhase` atomically
6) Recompute availability based on phase
7) Persist updated run state
8) Implement debug/admin phase inspection
9) Implement debug-only manual phase advancement
10) (Optional) Implement debug-only phase rollback
11) Validate restart safety and non-retriggering behavior
12) **Verify that all code written during this milestone was commented at creation time**

Each step must be verifiable by scanning code and persisted state.

---

## 8. What Comes After M4

Subsequent milestones will:
- Introduce scoring/points as a derived system
- Apply curses, rewards, or penalties tied to phase progression
- Define win/loss conditions
- Add pacing, time pressure, and player-facing feedback
