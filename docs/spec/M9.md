# CURSED — Milestone M9
## Live Penalty & Score Redistribution Engine

---

## 0. CRITICAL IMPLEMENTATION RULE (APPLIES TO THIS AND ALL FUTURE MILESTONES)

When implementing this milestone (and every milestone thereafter):

- **All non-trivial code MUST include explicit, explanatory comments**
- Comments must:
    - explain **what the code does**
    - explain **why it exists**
    - explain **how it fits into the larger system**
- Comments must be written so that:
    - a third party with no prior context
    - or a future maintainer months/years later  
      can understand the intent and structure without external documentation

This is not optional.  
Lack of clear comments is considered incomplete implementation.

### COMMENTING RULE (CLARIFICATION — NON-NEGOTIABLE)

- Comments are written **at the moment code is created**, not afterward.
- There is **no separate “commenting phase”**.
- No class, method, or non-trivial logic may exist without comments explaining:
    - its responsibility
    - its boundaries
    - and why it exists at that location in the system.
- If a piece of code cannot be clearly commented while being written, implementation **must pause** and the design must be reconsidered.
- “We will add comments later” is considered **invalid and incomplete implementation**.

---

## 1. Purpose of M9

Milestone M9 introduces **live penalty mechanics** that operate during an active run.

Penalties subtract points from teams in real time and may optionally redistribute a portion of those points to other teams. All effects are applied immediately, reflected live in standings, and permanently persisted.

M9 does not define win conditions, post-run rewards, or score calculation logic. It strictly modifies team score during the RUNNING state.

---

## 2. Scope

### Included in M9
- Live penalty engine active while run state == RUNNING
- Penalty sources:
    - Player death
    - Curse-triggered penalties (from M5)
- Penalty effects:
    - Direct point subtraction
    - Percentage-based point subtraction
    - Optional redistribution to other teams
- Phase-scaled penalty magnitude
- Full integration with ScoreService (M6)
- Data-driven penalty configuration
- Debug/admin tooling for testing and tuning

### Explicitly Excluded from M9
- Run termination logic (M7)
- Winner determination or standings finalization (M8)
- Post-run reward distribution
- Player inventory loss
- UI or presentation layers
- Anti-griefing systems beyond scoring

---

## 3. Penalty Sources & Trigger Conditions

### 3.1 Player Death Penalty

**Trigger**
- Player death while:
    - run state == RUNNING
    - player belongs to a valid team

**Owner**
- Player’s team

**Rules**
- One penalty per death
- No penalty if:
    - run is terminal
    - player has no team
    - debug invulnerability is active

Cause of death is ignored in M9.

---

### 3.2 Curse-Triggered Penalties

**Trigger**
- Curse effect explicitly signals a penalty

**Owner**
- PLAYER curse → player’s team
- TEAM curse → owning team
- GLOBAL curse → all teams (applied individually)

**Rules**
- Curse must opt-in to penalty behavior
- Cooldowns and stacking rules are enforced
- Evaluation is server-side only

---

### 3.3 Trigger Guardrails

- One penalty per trigger event
- Must resolve owning team
- Must route through PenaltyService
- Must validate run state == RUNNING

---

## 4. Penalty Effects & Redistribution Model

### Supported penalty effects

1) **Direct subtraction**
- Fixed point removal

2) **Percentage-based subtraction**
- Percentage of current team score
- Clamped to prevent negative scores

3) **Redistribution (optional)**
- Portion of lost points redistributed immediately to other teams

### Redistribution rules (locked)

- Penalized team never receives redistributed points
- Redistribution pool = `lostPoints × redistributionFactor`
- Distribution strategies (data-driven):
    - equal split
    - inverse-score weighting
    - phase-weighted
- Remainders assigned deterministically

### Phase scaling
- Penalty magnitude may scale by:
    - current global phase
    - curse phase (if applicable)

### Safety
- Team scores never drop below zero
- No point creation from nothing
- Penalties must be idempotent

---

## 5. Penalty Data Files & Configuration

### Data location
src/main/resources/data/cursed/penalties/

### Required files
- `death_penalties.json`
- `curse_penalties.json`

### Conceptual schema
{
"type": "penalty_rules",
"penalty_id": "death_basic",
"enabled": true,
"base_penalty": {
"mode": "fixed | percent",
"value": 50
},
"phase_scaling": {
"1": 1.0,
"2": 1.25,
"3": 1.5,
"4": 1.75,
"5": 2.0
},
"redistribution": {
"enabled": true,
"factor": 0.5,
"strategy": "equal | inverse_score | phase_weighted"
},
"cooldown_ticks": 0,
"notes": "..."
}

### Validation rules
- Values ≥ 0
- Redistribution factor ∈ [0, 1]
- Phase scaling defined for all supported phases
- Disabled penalties safely ignored

---

## 6. Penalty Engine Integration & Persistence

### Single entry point (locked)

All penalties are applied via:
- `PenaltyService.applyPenalty(...)`

Rules:
- No direct score mutation outside PenaltyService
- Event listeners must never subtract points directly

### Integration with scoring (M6)

PenaltyService:
- Computes penalty magnitude
- Applies clamping
- Routes all score changes through ScoreService

### Persistence
- Penalty effects persist via score changes
- No separate penalty state required
- Restart-safe by design

### Idempotency & cooldowns
- Each penalty trigger has a unique event id
- Double application is prevented
- Cooldowns enforced per owner context

---

## 7. Debug & Admin Controls

All commands are debug/admin only.

### Required commands
1) Show active penalty rules
2) Show recent penalties (rolling log)
3) Force penalty application
4) Enable/disable penalty rules at runtime (non-persistent)

### Safety
- No bypass of idempotency
- No lifecycle mutation
- No negative scores

---

## 8. Implementation Steps (STRICT ORDER)

1. Implement PenaltyService (single entry point)
2. Load and validate penalty data files
3. Integrate death event triggers
4. Integrate curse penalty triggers
5. Implement phase scaling logic
6. Implement redistribution logic
7. Route all score changes through ScoreService
8. Enforce idempotency and cooldowns
9. Implement debug/admin commands
10. Verify restart safety and determinism
11. **Verify that all code written during this milestone was commented at creation time**

---

## 9. Result After M9

- Live penalties apply during the run
- Team scores rise and fall dynamically
- Redistribution creates tension and counter-play
- No run lifecycle or post-run logic is affected
- System is fully data-driven and solo-testable
