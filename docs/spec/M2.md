# CURSED — Milestone M2
## Objective Runtime, Team Finalization & Debug Progress Engine

---

## 0. CRITICAL IMPLEMENTATION RULE (APPLIES TO THIS AND ALL FUTURE MILESTONES)

When implementing this milestone (and every milestone thereafter):

- **All non-trivial code MUST include explicit, explanatory comments**
- Comments must:
  - explain **what the code does**
  - explain **why it exists**
  - explain **how it fits into the larger system**
- Comments must be written so that:
  - a third party with no prior context
  - or a future maintainer months/years later  
    can understand the intent and structure without external documentation

This is not optional.  
Lack of clear comments is considered incomplete implementation.

### COMMENTING RULE (CLARIFICATION — NON-NEGOTIABLE)

- Comments are written **at the moment code is created**, not afterward.
- There is **no separate “commenting phase”**.
- No class, method, or non-trivial logic may exist without comments explaining:
  - its responsibility
  - its boundaries
  - and why it exists at that location in the system.
- If a piece of code cannot be clearly commented while being written, implementation **must pause** and the design must be reconsidered.
- “We will add comments later” is considered **invalid and incomplete implementation**.

---

## 1. Purpose of M2

Milestone M2 introduces the first true gameplay-layer engine of CURSED, without yet wiring real player actions.

M2 turns objective and task data into **concrete runtime entities** at the start of a run. It defines how objectives and tasks are generated, instantiated, assigned to teams, tracked over time, and safely persisted across restarts.

M2 deliberately avoids player event wiring and gameplay consequences. Its purpose is to prove that the objective engine, team state, persistence, and phase gating work correctly before real gameplay logic is introduced in later milestones.

---

## 2. Scope

### Included in M2
- Completion of team mechanics (assignment + visibility)
- Objective and task generation at run start
- Phase-gated objective/task structure
- Assignment of objectives and tasks to teams
- Objective and task progress tracking
- Full persistence of objective, task, and team state
- Debug/admin-only inspection and manipulation of progress
- Deterministic and safe run start sequencing

### Explicitly Excluded from M2
- Player event wiring (block break, craft, kill, deliver, gather, etc.)
- Automatic phase advancement logic
- Rewards, curses, penalties, or effects
- Victory or failure conditions
- Player-facing UI (titles, boss bars, action bars)
- Balancing or tuning logic

---

## 3. Team Finalization & Visibility

Before objective generation can occur, team mechanics must be fully operational at runtime.

M2 completes the team system by ensuring that:
- players can be assigned to teams
- team membership is persisted
- team identity is immediately visible in-game

Team membership is authoritative at the CURSED runtime level and applies to all gameplay systems. Players never own objectives or progress individually; all contribution is attributed to their team.

As part of this milestone, CURSED synchronizes its internal team state with Minecraft scoreboard teams. Each CURSED team is mapped to a corresponding scoreboard team, allowing player names in chat and the tab list to reflect team identity via color.

Team colors are not cosmetic polish. They are a functional debugging and validation aid that makes it immediately obvious whether team assignment, persistence, and restoration work correctly.

Team creation and assignment are explicit administrative actions and are treated as prerequisites for objective generation and run start.

---

## 4. Objective & Task Generation and Phase-Gated Structure

Objective and task generation is a deterministic, one-time operation performed at run start.

All objectives and tasks for the entire run — across all phases and all teams — are generated before the run enters the RUNNING state.

Generation consumes already-validated objective data loaded during M1, including templates, pools, quantity rules, and constraints. No objective data is read from disk after run start.

Generated objectives and tasks are instantiated as persistent runtime entities, assigned stable identifiers, and stored in run state.

### Objective and task identity
- Identifiers are incrementing per run
- Identifiers are globally unique across all phases
- Identifiers do not reset per phase

### Phase-gated grouping
Objectives and tasks are grouped by their unlock phase.

Grouping represents **unlock timing only**. Objectives and tasks from earlier phases remain valid and completable even after the phase advances.

If generation fails for any reason — including invalid data, unsatisfied constraints, or empty pools — run start aborts and the run does not enter the RUNNING state.

---

## 5. Objective, Task, and Team State (Code-Aligned Reality)

### Enforced per-phase structure (current engine reality)

The engine currently enforces the following slot structure via validation logic:

- PRIMARY objectives:
  - Exactly 1 per phase
  - Enforced by validation
  - Uses DELIVER (locked via data)

- SECONDARY objectives:
  - Phases 1–4: exactly 2 per phase
  - Phase 5: exactly 0
  - Enforced by validation

- TASK slots:
  - Phases 1–4: count is data-driven via generator_rules range (min..max)
  - Phase 5: forced to 0..0
  - Enforced by validation

M2 must respect this structure as authoritative.

### Team state ownership
Objectives and tasks are owned by teams, not players.

For each team, CURSED maintains team state that tracks:
- objective identifiers
- task identifiers
- completion status
- objective- and task-specific progress data

Definitions are not duplicated per team. Definitions remain global; team state references them.

Availability is determined by:
- currentPhase
- unlockPhase of each objective/task

Completing objectives or tasks from earlier phases does not affect phase progression.

All team state is fully persistent.

---

## 6. Progress Updates & Debug Interaction (Debug-Driven Only)

M2 is intentionally debug-driven.

Objective and task progress is not updated by gameplay events in this milestone. Instead, administrators use debug commands to inspect, test, and manipulate run state.

### Required debug capabilities
- Inspect all objectives and tasks grouped by phase
- Inspect per-team objective/task state
- View completion and progress values
- Manually update progress
- Manually mark objectives and tasks as completed
- View current global phase and phase gating effects

### Constraints
- Debug commands must not allow invalid state
- Locked objectives/tasks must respect phase gating unless explicitly overridden
- All debug mutations must persist immediately
- Debug commands must be gated behind debug configuration

---

## 7. Run Start Preconditions & Initialization Sequence

### Preconditions
Before run start:
- Teams are enabled and finalized
- Team membership is defined
- Team-to-scoreboard synchronization is complete
- Objective data has already been loaded and validated (M1)

If any precondition fails, run start aborts with no state mutation.

### Initialization sequence
1. Lock run initialization
2. Generate all objectives and tasks
3. Assign objectives and tasks to teams
4. Initialize phase state
5. Persist full run state
6. Enter RUNNING state

Any failure aborts run start safely.

### Restart safety
Once RUNNING:
- All objectives, tasks, team state, progress, and phase are restored exactly
- No regeneration occurs on restart

---

## 8. What M2 Delivers

At the end of M2:
- Teams are fully functional and visible
- Objectives and tasks exist as runtime entities
- Teams own and progress objectives/tasks
- State survives restarts
- Debug tools allow full inspection and manipulation
- The objective engine is proven structurally sound

---

## 9. Explicit Implementation Steps (Authoritative)

Implementation of M2 must proceed in this order:

1. Complete team assignment logic
  - Implement player-to-team assignment
  - Persist team membership
  - Synchronize CURSED teams to scoreboard teams with colors

2. Implement objective and task generation runtime path
  - Consume already-validated generator data
  - Generate objectives and tasks for all phases
  - Assign stable incrementing identifiers
  - Group by unlock phase

3. Implement team objective/task state initialization
  - Create per-team state referencing generated identifiers
  - Initialize progress and completion fields

4. Persist initialized run state
  - Ensure atomic persistence
  - Abort safely on failure

5. Implement debug inspection commands
  - List objectives/tasks by phase
  - Inspect per-team state
  - Inspect phase gating

6. Implement debug mutation commands
  - Update progress
  - Mark completion
  - Persist changes immediately

7. Validate restart safety
  - Restart server
  - Confirm state restores exactly
  - Confirm no regeneration occurs

8. **Verify that all code written during this milestone was commented at creation time**
  - No uncommented classes, methods, or logic are allowed

No step may be skipped. Each step must be verifiable by scanning code and persisted state.

---

## 10. What Comes After M2

Subsequent milestones will:
- Wire player actions to task progress
- Implement phase advancement logic
- Introduce curses, rewards, and consequences
- Define run end conditions and player-facing feedback

Those concerns are explicitly excluded from M2.
