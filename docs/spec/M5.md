# CURSED — Milestone M5
## Curse System & Rotating Environmental Penalties

---

## 0. CRITICAL IMPLEMENTATION RULE (APPLIES TO THIS AND ALL FUTURE MILESTONES)

When implementing this milestone (and every milestone thereafter):

- **All non-trivial code MUST include explicit, explanatory comments**
- Comments must:
  - explain **what the code does**
  - explain **why it exists**
  - explain **how it fits into the larger system**
- Comments must be written so that:
  - a third party with no prior context
  - or a future maintainer months/years later  
    can understand the intent and structure without external documentation

This is not optional.  
Lack of clear comments is considered incomplete implementation.

### COMMENTING RULE (CLARIFICATION — NON-NEGOTIABLE)

- Comments are written **at the moment code is created**, not afterward.
- There is **no separate “commenting phase”**.
- No class, method, or non-trivial logic may exist without comments explaining:
  - its responsibility
  - its boundaries
  - and why it exists at that location in the system.
- If a piece of code cannot be clearly commented while being written, implementation **must pause** and the design must be reconsidered.
- “We will add comments later” is considered **invalid and incomplete implementation**.

---

## 1. Purpose of M5

Milestone M5 introduces a deterministic and rotating curse system that adds environmental danger and systemic penalties to players and teams during an active run.

Curses are driven primarily by cursed block types and are applied when players stand on blocks matching active cursed rules. The system escalates across phases, rotates over time, and remains fully persistent and server-authoritative.

M5 does not alter progression mechanics. It reacts to the run and phase systems introduced in earlier milestones to introduce pressure and stakes without defining final win or failure states.

---

## 2. Curse Model

Curses are defined as rules attached to **block types**, not world positions.

Each cursed block rule contains:
- blockTypeId
- category: PLAYER | TEAM | GLOBAL
- phaseAssigned
- effectProfileId
- owner:
  - PLAYER → player UUID
  - TEAM → team id
  - GLOBAL → none

The world remains unchanged; the curse exists purely as a runtime rule evaluated by the engine.

---

## 3. Ownership Rules (Locked)

Nothing is shared between owners.

- PLAYER curses apply only to their owning player
- TEAM curses apply only to members of the owning team
- GLOBAL curses apply to all players

All curse sets are generated **per owner**, never shared.

---

## 4. Curse Cycling System

Each curse category maintains its own rotating active sets of cursed block types.

Rotation is:
- phase-aware
- deterministic
- persistent
- category-staggered using jitter

Each category tracks:
- active block-type sets per owner
- next rotation timestamp
- rotation index / seed

Offline players and teams retain their curse sets and continue rotating.

---

## 5. Selection Constraints

Curse selection must enforce:
- no duplicates within active sets
- no cross-category overlap
- repeat-avoidance from previous rotation if possible
- exclusion of invalid blocks (air, liquids, portals, admin blocks)

Fallback behavior must be deterministic and logged explicitly.

---

## 6. Curse Application Mechanics

- Curse evaluation runs server-side via a periodic tick loop
- Trigger: player standing on a cursed block type
- Supports EVENT and TICK effect profiles
- Applies per-player effects respecting ownership rules
- Enforces cooldown and stacking policies
- Custom curse state must persist if used

---

## 7. Rotation Execution Rules

- Rotation is driven by **run-time ticks**, not wallclock time
- Rotation advances only while run state == RUNNING
- On rotation due:
  - regenerate active curse sets per owner/category
  - compute next rotation timestamp with jitter
  - persist atomically

Phase advancement does **not** force immediate rotation.

---

## 8. Effect Profiles

Effect profiles define what happens when a cursed block type is triggered.

Profiles are fully data-driven and include:
- mode (EVENT / TICK)
- cooldown
- stacking behavior
- effect components (damage, potion effects, hunger, feedback)

Profiles are validated on load.

---

## 9. Curse Generator Rules (Data Driven)

Per-phase generator files define:
- active curse counts per category
- eligible block pools
- effect profile pools
- rotation interval and jitter
- constraint references
- retry budgets

Structure mirrors the objective generator system.

### 9.1 Eligible Block Pools: Tags + Explicit IDs (LOCKED)

Eligible block pools may contain both:
- **Minecraft block tags** (e.g. `#minecraft:logs`)
- **Explicit block IDs** (e.g. `minecraft:grass_block`)

Rules:
- Tag entries must be expanded into concrete block IDs during loading/selection.
- After expansion, selection constraints (no duplicates, no overlap, repeat-avoidance, invalid exclusions) apply to the resolved block ID set.
- If a tag resolves to zero valid blocks (after exclusions), fallback behavior must be deterministic and logged explicitly.

---

## 10. Activation Model

- On run start → generate initial curse sets
- On pause → suspend evaluation and rotation
- On resume → continue schedules without re-roll
- On phase change → next rotation uses updated phase rules

---

## 11. Debug & Admin Controls

Debug/admin commands must allow:
- inspect active curse sets per owner/category
- view rotation timers
- force rotations
- add/remove cursed block types
- regenerate sets
- manually trigger effect profiles for testing

All commands must be gated and logged.

---

## 12. Persistence Requirements

Persist:
- active curse sets per owner/category
- rotation schedule state
- rotation indices
- repeat history (previous sets)
- custom per-player curse state if used

System must restore **exactly** after restart.

---

## 13. Explicit Implementation Steps (Authoritative)

Implementation must proceed in this order:

1. Introduce curse rule data model (block-type based)
2. Implement per-owner curse storage
3. Implement effect profile loader and validator
4. Implement server-side standing-on detection loop
5. Implement curse effect application engine
6. Implement cooldown and stacking mechanics
7. Implement rotation scheduler per category
8. Implement deterministic pool selection with constraints
9. Persist curse state within run state
10. Integrate run start / pause / resume hooks
11. Integrate phase awareness
12. Implement debug/admin commands
13. **Verify that all code written during this milestone was commented at creation time**

No step may be skipped.

---

## 14. Result After M5

- The world gains rotating environmental danger
- Players and teams face dynamic penalties tied to block types
- Danger escalates per phase
- Curses rotate deterministically and persist safely
- System is ready to support future penalty and scoring layers
