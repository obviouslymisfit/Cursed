# CURSED — Milestone M6
## Team Scoring Engine

---

## 0. CRITICAL IMPLEMENTATION RULE (APPLIES TO THIS AND ALL FUTURE MILESTONES)

When implementing this milestone (and every milestone thereafter):

- **All non-trivial code MUST include explicit, explanatory comments**
- Comments must:
    - explain **what the code does**
    - explain **why it exists**
    - explain **how it fits into the larger system**
- Comments must be written so that:
    - a third party with no prior context
    - or a future maintainer months/years later  
      can understand the intent and structure without external documentation

This is not optional.  
Lack of clear comments is considered incomplete implementation.

### COMMENTING RULE (CLARIFICATION — NON-NEGOTIABLE)

- Comments are written **at the moment code is created**, not afterward.
- There is **no separate “commenting phase”**.
- No class, method, or non-trivial logic may exist without comments explaining:
    - its responsibility
    - its boundaries
    - and why it exists at that location in the system.
- If a piece of code cannot be clearly commented while being written, implementation **must pause** and the design must be reconsidered.
- “We will add comments later” is considered **invalid and incomplete implementation**.

---

## 1. Purpose of M6

Milestone M6 introduces a server-authoritative scoring system that quantifies team performance throughout a run.

Points are awarded strictly based on objective and task completion across phases, transforming progression into measurable competition. Players do not earn points individually — only teams accumulate score.

M6 does not define win conditions, rewards, penalties, or redistribution. It establishes how points are generated, tracked, persisted, and exposed for debugging and future systems.

---

## 2. Scope

### Included in M6
- Team-based scoring engine
- Point awards triggered strictly by:
    - PRIMARY objective completion
    - SECONDARY objective completion
    - TASK completion
- Phase-aware scoring via data-driven multipliers
- Persistent storage of team scores in run state
- Debug/admin inspection of team scores
- Deterministic score rebuild capability from persisted completions

### Explicitly Excluded from M6
- Win/loss logic
- Rewards or loot
- Player-level scoring
- Ranking UI or leaderboards (beyond debug readout)
- Time bonuses/penalties
- Curse-related scoring interactions
- Death penalties or point redistribution

Scoring is purely a numerical reflection of objective/task completions.

---

## 3. Scoring Model

### Score ownership
- Only teams have score.
- Players never store points individually.
- Team score is cumulative for the entire run.

### Point sources
Teams gain points only from completed items:

- PRIMARY objective completion
- SECONDARY objective completion
- TASK completion

### Phase multiplier (mechanic locked, values data-driven)
Each completed item is multiplied by the phase it belongs to:

finalPoints = basePoints × phaseMultiplier(itemPhase)

Phase multipliers increase with phases to reward later progression and risk.

### Base values per type (mechanics locked, numbers configurable)
- PRIMARY → high value
- SECONDARY → medium value
- TASK → low value

### Award timing
Points are granted instantly when:
- a task transitions → COMPLETED
- an objective transitions → COMPLETED

### Deterministic rebuild safety
Score may be rebuilt from persisted completion flags by rescanning completed objectives/tasks and reapplying scoring rules deterministically.

---

## 4. Score Storage & Run State Shape

Score is stored at run level, mapped strictly to teams.

Minimum required persisted structure:

teamScores:
teamId:
totalPoints: int
breakdown:
primary: int
secondary: int
tasks: int

Breakdown is mandatory for debugging and future milestone integration.

Rules:
- Score entries are created automatically when a team exists
- No deletion during a run
- Score persists atomically with run state
- Restart restores exact values

---

## 5. Scoring Data Files (Data-Driven)

Add:

src/main/resources/data/cursed/scoring/

Required file:
- score_rules.json

Suggested schema:

{
"type": "score_rules",
"base_points": {
"primary": <int>,
"secondary": <int>,
"task": <int>
},
"phase_multipliers": {
"1": <float>,
"2": <float>,
"3": <float>,
"4": <float>,
"5": <float>
},
"notes": "..."
}

Validation rules:
- multipliers must exist for all supported phases
- base points must be non-negative ints
- multipliers must be >= 1.0

---

## 6. Award Triggers & Integration Points

### Single entry point
All score awards go through a single scoring service. No direct awarding in listeners or commands.

### Authoritative triggers
Points are awarded only on state transitions:
- Task → COMPLETED → award TASK points
- Objective → COMPLETED:
    - PRIMARY → award PRIMARY points
    - SECONDARY → award SECONDARY points

### Phase used for scoring
Use the phase of the completed item, not current global phase.

Example:
- Phase 1 objective completed during Phase 3 uses Phase 1 multiplier.

### Idempotency guarantee
Points must be awarded only once per completion event.

Score awarding must be stable across restarts.

### Persistence coupling
Score changes are persisted immediately as part of run state.

---

## 7. Debug Commands for Scoring

All scoring debug commands require debug mode enabled.

Required commands:
1) Score overview
- list all teams with total score + breakdown

2) Team score detail
- show total + breakdown for a specific team

3) Rebuild score (safety tool)
- clears score and rebuilds deterministically from completion flags

Optional:
4) Set score
- debug-only manual score setting for test scenarios
- logged loudly and persisted immediately

---

## 8. Implementation Steps (STRICT ORDER)

1. Add scoring data loader for score_rules.json + validation
2. Add teamScores structure to run state + persistence integration
3. Implement ScoreService as the single award entry point
4. Wire awards into objective/task completion transitions only
5. Enforce idempotency (no double-awards)
6. Persist score updates atomically with run state
7. Implement debug commands:
    - score overview
    - team score detail
    - rebuild score
    - optional set score
8. Verify restart safety and rebuild correctness
9. **Verify that all code written during this milestone was commented at creation time**

---

## 9. Result After M6

- Teams accumulate deterministic points from completion events
- Scoring scales with phase via data-driven multipliers
- Score persists safely and can be rebuilt for verification
- Foundation is ready for win conditions, penalties, rewards, and competitive modifiers in later milestones
