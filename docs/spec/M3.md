# CURSED — Milestone M3
## Player Action Wiring & Event-to-Progress Engine

---

## 0. CRITICAL IMPLEMENTATION RULE (APPLIES TO THIS AND ALL FUTURE MILESTONES)

When implementing this milestone (and every milestone thereafter):

- **All non-trivial code MUST include explicit, explanatory comments**
- Comments must:
  - explain **what the code does**
  - explain **why it exists**
  - explain **how it fits into the larger system**
- Comments must be written so that:
  - a third party with no prior context
  - or a future maintainer months/years later  
    can understand the intent and structure without external documentation

This is not optional.  
Lack of clear comments is considered incomplete implementation.

### COMMENTING RULE (CLARIFICATION — NON-NEGOTIABLE)

- Comments are written **at the moment code is created**, not afterward.
- There is **no separate “commenting phase”**.
- No class, method, or non-trivial logic may exist without comments explaining:
  - its responsibility
  - its boundaries
  - and why it exists at that location in the system.
- If a piece of code cannot be clearly commented while being written, implementation **must pause** and the design must be reconsidered.
- “We will add comments later” is considered **invalid and incomplete implementation**.

---

## 1. Purpose of M3

Milestone M3 introduces real gameplay interaction by wiring player actions to task progress.

M3 connects Minecraft game events to the objective and task engine established in M2, allowing teams to progress tasks through actual in-game behavior.

M3 does not change objective structure, phase rules, or progression logic. It focuses exclusively on translating player actions into **team-level task progress** in a controlled, deterministic, and debuggable way.

Points, scoring, rewards, curses, phase advancement, and win conditions are intentionally excluded and deferred to later milestones.

---

## 2. Scope

### Included in M3
- Wiring player gameplay events to task progress
- TEAM_GATHER evaluation via team-wide inventory aggregation
- CRAFT progress via crafting output collection
- SMELT progress via smelting output collection
- DELIVER progress via **debug-only submission command**
- Deterministic progress allocation
- Immediate persistence of all state changes
- Solo-developer friendly testing workflow

### Explicitly Excluded from M3
- Points or scoring systems
- Phase advancement logic
- Rewards, curses, penalties, or consequences
- Delivery chest or world-state delivery systems
- Player-facing UI beyond minimal feedback messages
- Balancing or tuning of generator rules

---

## 3. Core Invariants

- **Teams are the atomic gameplay unit**
  - Players never own progress
  - All progress belongs to teams

- **Phase gating is enforced**
  - Locked tasks/objectives must not progress

- **Single mutation path**
  - All progress updates go through a central engine mutation path
  - No ad-hoc state writes inside event listeners

- **Deterministic behavior**
  - Allocation order is stable
  - Restarts never alter outcomes

---

## 4. Supported Action Types

M3 wires exactly the action types already present in objective definitions:

- TEAM_GATHER
- CRAFT
- SMELT
- DELIVER (testing-only, command-based)

No new action types are introduced in this milestone.

---

## 5. TEAM_GATHER — Event-Driven Evaluation

### Semantics
TEAM_GATHER progress is based on **team-wide inventory totals**.

At evaluation time:
- The system sums required item counts across **all online members of the team**
- Items are **not consumed**
- Completion occurs the moment totals meet or exceed the requirement

### Trigger model
TEAM_GATHER evaluation is **event-driven**, not polled.

Minimum triggering events:
- Item pickup
- Item removal (drop, submit, consume)
- Craft result collection
- Smelt result collection
- Player join/leave
- Player death

### Evaluation rules
- Only evaluate tasks for the affected player’s team
- No global scans
- No background loops
- Progress updates must be idempotent

---

## 6. CRAFT & SMELT — Output-Based Progress

### Counting rule
Progress is credited based on **output items actually received**, not on:
- recipe matches
- ghost outputs
- ingredient consumption

### Attribution
- Progress is attributed to the team of the player who receives the output
- Players without teams grant no progress

### Amount handling
- Stack outputs increment progress by actual stack size received
- Shift-click / bulk collection increments by total received amount

### Matching & allocation
When output item `X` is collected:
- Consider only unlocked, incomplete tasks of matching action type
- Apply progress deterministically:
  - earliest unlock phase first
  - then stable definition order
- Fill tasks until progress is exhausted

### Anti-double-counting invariant
Progress is updated **only once per output collection event**.

---

## 7. DELIVER — Debug-Only Submission (Testing-Only)

### Purpose
DELIVER is implemented as a **debug-only command** in M3 to:
- enable solo testing
- validate accumulation behavior
- avoid world-state delivery complexity

### Command gating
DELIVER submission must only be available when **debug mode is enabled**.

### Command shape
/curse debug submit <item_id> <count>

### Preconditions
- Run state is RUNNING
- Player is assigned to a team
- `<count> > 0`

If any precondition fails:
- no state changes occur
- player receives a clear error message

### Inventory removal & partial submission
- Items are removed from the submitting player’s inventory
- If fewer than `<count>` items exist, submit only what is available
- Zero inventory results in no mutation

### Accumulation & allocation (“deliver in pieces”)
- DELIVER requirements accumulate across time
- Completion occurs only when deposited progress meets requirement

Allocation rule:
1) Consider unlocked, incomplete DELIVER requirements
2) Match by item type
3) Sort deterministically (phase → stable order)
4) Fill each requirement until complete, then continue until items run out

### State updates
- Increment deposited progress counters
- Mark tasks completed when satisfied
- Evaluate objective completion if applicable
- Persist immediately

No scoring, phase advancement, or rewards are triggered in M3.

---

## 8. Debug Feedback

Minimal feedback is required:
- submitted item and amount
- progress update (e.g. `128/256`)
- completion notifications

Avoid spamming output on every incremental change.

---

## 9. Persistence & Restart Safety

All progress mutations:
- persist immediately
- survive server restarts
- never regenerate or duplicate progress

After restart:
- TEAM_GATHER re-evaluates correctly on next triggering event
- CRAFT/SMELT/DELIVER progress remains unchanged

---

## 10. Solo Test Checklist

### Preconditions
- Debug mode enabled
- Teams configured and assigned
- Team color visible in chat/tab
- Run started successfully

### TEAM_GATHER tests
- Pick up required items
- Drop/remove items
- Verify progress reflects inventory totals
- Confirm no consumption occurs

### CRAFT tests
- Craft required output
- Verify correct increment
- Test bulk crafting
- Confirm no double counting

### SMELT tests
- Smelt required output
- Verify progress only on output collection

### DELIVER tests
- Submit items via debug command
- Test partial submission
- Test irrelevant items
- Confirm inventory removal
- Confirm accumulation and completion

### Restart tests
- Restart mid-progress
- Verify state restores exactly
- Confirm no regeneration or duplication

---

## 11. Explicit Implementation Steps (Authoritative)

Implementation must proceed in this order:

1. Add Fabric event hooks for inventory-affecting events
2. Route all events through a central task progress engine
3. Implement TEAM_GATHER evaluation logic
4. Implement CRAFT output detection and progress updates
5. Implement SMELT output detection and progress updates
6. Implement debug-only DELIVER submission command
7. Enforce debug gating and preconditions
8. Persist all state mutations immediately
9. Validate restart safety across all action types
10. **Verify that all code written during this milestone was commented at creation time**

Each step must be verifiable by scanning code and persisted state.

---

## 12. What Comes After M3

Subsequent milestones will:
- Introduce phase advancement logic
- Add scoring/points as a derived system
- Introduce curses, rewards, and consequences
- Implement real delivery systems (e.g. delivery chests)
- Add player-facing UI and feedback
